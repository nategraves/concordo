// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateFeedbackMedia {
  count: Int!
}

type AggregateFeedbackProject {
  count: Int!
}

type AggregateFeedbackRound {
  count: Int!
}

type AggregateFeedbackSubject {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type FeedbackMedia {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  subject: FeedbackProject!
}

type FeedbackMediaConnection {
  pageInfo: PageInfo!
  edges: [FeedbackMediaEdge]!
  aggregate: AggregateFeedbackMedia!
}

input FeedbackMediaCreateInput {
  id: ID
  name: String!
  subject: FeedbackProjectCreateOneInput!
}

type FeedbackMediaEdge {
  node: FeedbackMedia!
  cursor: String!
}

enum FeedbackMediaOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FeedbackMediaPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FeedbackMediaSubscriptionPayload {
  mutation: MutationType!
  node: FeedbackMedia
  updatedFields: [String!]
  previousValues: FeedbackMediaPreviousValues
}

input FeedbackMediaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FeedbackMediaWhereInput
  AND: [FeedbackMediaSubscriptionWhereInput!]
  OR: [FeedbackMediaSubscriptionWhereInput!]
  NOT: [FeedbackMediaSubscriptionWhereInput!]
}

input FeedbackMediaUpdateInput {
  name: String
  subject: FeedbackProjectUpdateOneRequiredInput
}

input FeedbackMediaUpdateManyMutationInput {
  name: String
}

input FeedbackMediaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  subject: FeedbackProjectWhereInput
  AND: [FeedbackMediaWhereInput!]
  OR: [FeedbackMediaWhereInput!]
  NOT: [FeedbackMediaWhereInput!]
}

input FeedbackMediaWhereUniqueInput {
  id: ID
}

type FeedbackProject {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: User
}

type FeedbackProjectConnection {
  pageInfo: PageInfo!
  edges: [FeedbackProjectEdge]!
  aggregate: AggregateFeedbackProject!
}

input FeedbackProjectCreateInput {
  id: ID
  name: String!
  createdBy: UserCreateOneWithoutFeedbackProjectsInput
}

input FeedbackProjectCreateManyWithoutCreatedByInput {
  create: [FeedbackProjectCreateWithoutCreatedByInput!]
  connect: [FeedbackProjectWhereUniqueInput!]
}

input FeedbackProjectCreateOneInput {
  create: FeedbackProjectCreateInput
  connect: FeedbackProjectWhereUniqueInput
}

input FeedbackProjectCreateWithoutCreatedByInput {
  id: ID
  name: String!
}

type FeedbackProjectEdge {
  node: FeedbackProject!
  cursor: String!
}

enum FeedbackProjectOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FeedbackProjectPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input FeedbackProjectScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FeedbackProjectScalarWhereInput!]
  OR: [FeedbackProjectScalarWhereInput!]
  NOT: [FeedbackProjectScalarWhereInput!]
}

type FeedbackProjectSubscriptionPayload {
  mutation: MutationType!
  node: FeedbackProject
  updatedFields: [String!]
  previousValues: FeedbackProjectPreviousValues
}

input FeedbackProjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FeedbackProjectWhereInput
  AND: [FeedbackProjectSubscriptionWhereInput!]
  OR: [FeedbackProjectSubscriptionWhereInput!]
  NOT: [FeedbackProjectSubscriptionWhereInput!]
}

input FeedbackProjectUpdateDataInput {
  name: String
  createdBy: UserUpdateOneWithoutFeedbackProjectsInput
}

input FeedbackProjectUpdateInput {
  name: String
  createdBy: UserUpdateOneWithoutFeedbackProjectsInput
}

input FeedbackProjectUpdateManyDataInput {
  name: String
}

input FeedbackProjectUpdateManyMutationInput {
  name: String
}

input FeedbackProjectUpdateManyWithoutCreatedByInput {
  create: [FeedbackProjectCreateWithoutCreatedByInput!]
  delete: [FeedbackProjectWhereUniqueInput!]
  connect: [FeedbackProjectWhereUniqueInput!]
  set: [FeedbackProjectWhereUniqueInput!]
  disconnect: [FeedbackProjectWhereUniqueInput!]
  update: [FeedbackProjectUpdateWithWhereUniqueWithoutCreatedByInput!]
  upsert: [FeedbackProjectUpsertWithWhereUniqueWithoutCreatedByInput!]
  deleteMany: [FeedbackProjectScalarWhereInput!]
  updateMany: [FeedbackProjectUpdateManyWithWhereNestedInput!]
}

input FeedbackProjectUpdateManyWithWhereNestedInput {
  where: FeedbackProjectScalarWhereInput!
  data: FeedbackProjectUpdateManyDataInput!
}

input FeedbackProjectUpdateOneRequiredInput {
  create: FeedbackProjectCreateInput
  update: FeedbackProjectUpdateDataInput
  upsert: FeedbackProjectUpsertNestedInput
  connect: FeedbackProjectWhereUniqueInput
}

input FeedbackProjectUpdateWithoutCreatedByDataInput {
  name: String
}

input FeedbackProjectUpdateWithWhereUniqueWithoutCreatedByInput {
  where: FeedbackProjectWhereUniqueInput!
  data: FeedbackProjectUpdateWithoutCreatedByDataInput!
}

input FeedbackProjectUpsertNestedInput {
  update: FeedbackProjectUpdateDataInput!
  create: FeedbackProjectCreateInput!
}

input FeedbackProjectUpsertWithWhereUniqueWithoutCreatedByInput {
  where: FeedbackProjectWhereUniqueInput!
  update: FeedbackProjectUpdateWithoutCreatedByDataInput!
  create: FeedbackProjectCreateWithoutCreatedByInput!
}

input FeedbackProjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdBy: UserWhereInput
  AND: [FeedbackProjectWhereInput!]
  OR: [FeedbackProjectWhereInput!]
  NOT: [FeedbackProjectWhereInput!]
}

input FeedbackProjectWhereUniqueInput {
  id: ID
}

type FeedbackRound {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  roundEnd: DateTime
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type FeedbackRoundConnection {
  pageInfo: PageInfo!
  edges: [FeedbackRoundEdge]!
  aggregate: AggregateFeedbackRound!
}

input FeedbackRoundCreateInput {
  id: ID
  roundEnd: DateTime
  users: UserCreateManyWithoutFeedbackRoundsInput
}

input FeedbackRoundCreateManyWithoutUsersInput {
  create: [FeedbackRoundCreateWithoutUsersInput!]
  connect: [FeedbackRoundWhereUniqueInput!]
}

input FeedbackRoundCreateWithoutUsersInput {
  id: ID
  roundEnd: DateTime
}

type FeedbackRoundEdge {
  node: FeedbackRound!
  cursor: String!
}

enum FeedbackRoundOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  roundEnd_ASC
  roundEnd_DESC
}

type FeedbackRoundPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  roundEnd: DateTime
}

input FeedbackRoundScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  roundEnd: DateTime
  roundEnd_not: DateTime
  roundEnd_in: [DateTime!]
  roundEnd_not_in: [DateTime!]
  roundEnd_lt: DateTime
  roundEnd_lte: DateTime
  roundEnd_gt: DateTime
  roundEnd_gte: DateTime
  AND: [FeedbackRoundScalarWhereInput!]
  OR: [FeedbackRoundScalarWhereInput!]
  NOT: [FeedbackRoundScalarWhereInput!]
}

type FeedbackRoundSubscriptionPayload {
  mutation: MutationType!
  node: FeedbackRound
  updatedFields: [String!]
  previousValues: FeedbackRoundPreviousValues
}

input FeedbackRoundSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FeedbackRoundWhereInput
  AND: [FeedbackRoundSubscriptionWhereInput!]
  OR: [FeedbackRoundSubscriptionWhereInput!]
  NOT: [FeedbackRoundSubscriptionWhereInput!]
}

input FeedbackRoundUpdateInput {
  roundEnd: DateTime
  users: UserUpdateManyWithoutFeedbackRoundsInput
}

input FeedbackRoundUpdateManyDataInput {
  roundEnd: DateTime
}

input FeedbackRoundUpdateManyMutationInput {
  roundEnd: DateTime
}

input FeedbackRoundUpdateManyWithoutUsersInput {
  create: [FeedbackRoundCreateWithoutUsersInput!]
  delete: [FeedbackRoundWhereUniqueInput!]
  connect: [FeedbackRoundWhereUniqueInput!]
  set: [FeedbackRoundWhereUniqueInput!]
  disconnect: [FeedbackRoundWhereUniqueInput!]
  update: [FeedbackRoundUpdateWithWhereUniqueWithoutUsersInput!]
  upsert: [FeedbackRoundUpsertWithWhereUniqueWithoutUsersInput!]
  deleteMany: [FeedbackRoundScalarWhereInput!]
  updateMany: [FeedbackRoundUpdateManyWithWhereNestedInput!]
}

input FeedbackRoundUpdateManyWithWhereNestedInput {
  where: FeedbackRoundScalarWhereInput!
  data: FeedbackRoundUpdateManyDataInput!
}

input FeedbackRoundUpdateWithoutUsersDataInput {
  roundEnd: DateTime
}

input FeedbackRoundUpdateWithWhereUniqueWithoutUsersInput {
  where: FeedbackRoundWhereUniqueInput!
  data: FeedbackRoundUpdateWithoutUsersDataInput!
}

input FeedbackRoundUpsertWithWhereUniqueWithoutUsersInput {
  where: FeedbackRoundWhereUniqueInput!
  update: FeedbackRoundUpdateWithoutUsersDataInput!
  create: FeedbackRoundCreateWithoutUsersInput!
}

input FeedbackRoundWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  roundEnd: DateTime
  roundEnd_not: DateTime
  roundEnd_in: [DateTime!]
  roundEnd_not_in: [DateTime!]
  roundEnd_lt: DateTime
  roundEnd_lte: DateTime
  roundEnd_gt: DateTime
  roundEnd_gte: DateTime
  users_every: UserWhereInput
  users_some: UserWhereInput
  users_none: UserWhereInput
  AND: [FeedbackRoundWhereInput!]
  OR: [FeedbackRoundWhereInput!]
  NOT: [FeedbackRoundWhereInput!]
}

input FeedbackRoundWhereUniqueInput {
  id: ID
}

type FeedbackSubject {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  project: FeedbackProject!
  createdBy: User
}

type FeedbackSubjectConnection {
  pageInfo: PageInfo!
  edges: [FeedbackSubjectEdge]!
  aggregate: AggregateFeedbackSubject!
}

input FeedbackSubjectCreateInput {
  id: ID
  name: String!
  project: FeedbackProjectCreateOneInput!
  createdBy: UserCreateOneInput
}

type FeedbackSubjectEdge {
  node: FeedbackSubject!
  cursor: String!
}

enum FeedbackSubjectOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FeedbackSubjectPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FeedbackSubjectSubscriptionPayload {
  mutation: MutationType!
  node: FeedbackSubject
  updatedFields: [String!]
  previousValues: FeedbackSubjectPreviousValues
}

input FeedbackSubjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FeedbackSubjectWhereInput
  AND: [FeedbackSubjectSubscriptionWhereInput!]
  OR: [FeedbackSubjectSubscriptionWhereInput!]
  NOT: [FeedbackSubjectSubscriptionWhereInput!]
}

input FeedbackSubjectUpdateInput {
  name: String
  project: FeedbackProjectUpdateOneRequiredInput
  createdBy: UserUpdateOneInput
}

input FeedbackSubjectUpdateManyMutationInput {
  name: String
}

input FeedbackSubjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  project: FeedbackProjectWhereInput
  createdBy: UserWhereInput
  AND: [FeedbackSubjectWhereInput!]
  OR: [FeedbackSubjectWhereInput!]
  NOT: [FeedbackSubjectWhereInput!]
}

input FeedbackSubjectWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createFeedbackMedia(data: FeedbackMediaCreateInput!): FeedbackMedia!
  updateFeedbackMedia(data: FeedbackMediaUpdateInput!, where: FeedbackMediaWhereUniqueInput!): FeedbackMedia
  updateManyFeedbackMedias(data: FeedbackMediaUpdateManyMutationInput!, where: FeedbackMediaWhereInput): BatchPayload!
  upsertFeedbackMedia(where: FeedbackMediaWhereUniqueInput!, create: FeedbackMediaCreateInput!, update: FeedbackMediaUpdateInput!): FeedbackMedia!
  deleteFeedbackMedia(where: FeedbackMediaWhereUniqueInput!): FeedbackMedia
  deleteManyFeedbackMedias(where: FeedbackMediaWhereInput): BatchPayload!
  createFeedbackProject(data: FeedbackProjectCreateInput!): FeedbackProject!
  updateFeedbackProject(data: FeedbackProjectUpdateInput!, where: FeedbackProjectWhereUniqueInput!): FeedbackProject
  updateManyFeedbackProjects(data: FeedbackProjectUpdateManyMutationInput!, where: FeedbackProjectWhereInput): BatchPayload!
  upsertFeedbackProject(where: FeedbackProjectWhereUniqueInput!, create: FeedbackProjectCreateInput!, update: FeedbackProjectUpdateInput!): FeedbackProject!
  deleteFeedbackProject(where: FeedbackProjectWhereUniqueInput!): FeedbackProject
  deleteManyFeedbackProjects(where: FeedbackProjectWhereInput): BatchPayload!
  createFeedbackRound(data: FeedbackRoundCreateInput!): FeedbackRound!
  updateFeedbackRound(data: FeedbackRoundUpdateInput!, where: FeedbackRoundWhereUniqueInput!): FeedbackRound
  updateManyFeedbackRounds(data: FeedbackRoundUpdateManyMutationInput!, where: FeedbackRoundWhereInput): BatchPayload!
  upsertFeedbackRound(where: FeedbackRoundWhereUniqueInput!, create: FeedbackRoundCreateInput!, update: FeedbackRoundUpdateInput!): FeedbackRound!
  deleteFeedbackRound(where: FeedbackRoundWhereUniqueInput!): FeedbackRound
  deleteManyFeedbackRounds(where: FeedbackRoundWhereInput): BatchPayload!
  createFeedbackSubject(data: FeedbackSubjectCreateInput!): FeedbackSubject!
  updateFeedbackSubject(data: FeedbackSubjectUpdateInput!, where: FeedbackSubjectWhereUniqueInput!): FeedbackSubject
  updateManyFeedbackSubjects(data: FeedbackSubjectUpdateManyMutationInput!, where: FeedbackSubjectWhereInput): BatchPayload!
  upsertFeedbackSubject(where: FeedbackSubjectWhereUniqueInput!, create: FeedbackSubjectCreateInput!, update: FeedbackSubjectUpdateInput!): FeedbackSubject!
  deleteFeedbackSubject(where: FeedbackSubjectWhereUniqueInput!): FeedbackSubject
  deleteManyFeedbackSubjects(where: FeedbackSubjectWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  feedbackMedia(where: FeedbackMediaWhereUniqueInput!): FeedbackMedia
  feedbackMedias(where: FeedbackMediaWhereInput, orderBy: FeedbackMediaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FeedbackMedia]!
  feedbackMediasConnection(where: FeedbackMediaWhereInput, orderBy: FeedbackMediaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FeedbackMediaConnection!
  feedbackProject(where: FeedbackProjectWhereUniqueInput!): FeedbackProject
  feedbackProjects(where: FeedbackProjectWhereInput, orderBy: FeedbackProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FeedbackProject]!
  feedbackProjectsConnection(where: FeedbackProjectWhereInput, orderBy: FeedbackProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FeedbackProjectConnection!
  feedbackRound(where: FeedbackRoundWhereUniqueInput!): FeedbackRound
  feedbackRounds(where: FeedbackRoundWhereInput, orderBy: FeedbackRoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FeedbackRound]!
  feedbackRoundsConnection(where: FeedbackRoundWhereInput, orderBy: FeedbackRoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FeedbackRoundConnection!
  feedbackSubject(where: FeedbackSubjectWhereUniqueInput!): FeedbackSubject
  feedbackSubjects(where: FeedbackSubjectWhereInput, orderBy: FeedbackSubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FeedbackSubject]!
  feedbackSubjectsConnection(where: FeedbackSubjectWhereInput, orderBy: FeedbackSubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FeedbackSubjectConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  feedbackMedia(where: FeedbackMediaSubscriptionWhereInput): FeedbackMediaSubscriptionPayload
  feedbackProject(where: FeedbackProjectSubscriptionWhereInput): FeedbackProjectSubscriptionPayload
  feedbackRound(where: FeedbackRoundSubscriptionWhereInput): FeedbackRoundSubscriptionPayload
  feedbackSubject(where: FeedbackSubjectSubscriptionWhereInput): FeedbackSubjectSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  email: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  feedbackProjects(where: FeedbackProjectWhereInput, orderBy: FeedbackProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FeedbackProject!]
  feedbackRounds(where: FeedbackRoundWhereInput, orderBy: FeedbackRoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FeedbackRound!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  feedbackProjects: FeedbackProjectCreateManyWithoutCreatedByInput
  feedbackRounds: FeedbackRoundCreateManyWithoutUsersInput
}

input UserCreateManyWithoutFeedbackRoundsInput {
  create: [UserCreateWithoutFeedbackRoundsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutFeedbackProjectsInput {
  create: UserCreateWithoutFeedbackProjectsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutFeedbackProjectsInput {
  id: ID
  name: String!
  email: String!
  feedbackRounds: FeedbackRoundCreateManyWithoutUsersInput
}

input UserCreateWithoutFeedbackRoundsInput {
  id: ID
  name: String!
  email: String!
  feedbackProjects: FeedbackProjectCreateManyWithoutCreatedByInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
  email: String
  feedbackProjects: FeedbackProjectUpdateManyWithoutCreatedByInput
  feedbackRounds: FeedbackRoundUpdateManyWithoutUsersInput
}

input UserUpdateInput {
  name: String
  email: String
  feedbackProjects: FeedbackProjectUpdateManyWithoutCreatedByInput
  feedbackRounds: FeedbackRoundUpdateManyWithoutUsersInput
}

input UserUpdateManyDataInput {
  name: String
  email: String
}

input UserUpdateManyMutationInput {
  name: String
  email: String
}

input UserUpdateManyWithoutFeedbackRoundsInput {
  create: [UserCreateWithoutFeedbackRoundsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutFeedbackRoundsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutFeedbackRoundsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutFeedbackProjectsInput {
  create: UserCreateWithoutFeedbackProjectsInput
  update: UserUpdateWithoutFeedbackProjectsDataInput
  upsert: UserUpsertWithoutFeedbackProjectsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutFeedbackProjectsDataInput {
  name: String
  email: String
  feedbackRounds: FeedbackRoundUpdateManyWithoutUsersInput
}

input UserUpdateWithoutFeedbackRoundsDataInput {
  name: String
  email: String
  feedbackProjects: FeedbackProjectUpdateManyWithoutCreatedByInput
}

input UserUpdateWithWhereUniqueWithoutFeedbackRoundsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutFeedbackRoundsDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutFeedbackProjectsInput {
  update: UserUpdateWithoutFeedbackProjectsDataInput!
  create: UserCreateWithoutFeedbackProjectsInput!
}

input UserUpsertWithWhereUniqueWithoutFeedbackRoundsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutFeedbackRoundsDataInput!
  create: UserCreateWithoutFeedbackRoundsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  feedbackProjects_every: FeedbackProjectWhereInput
  feedbackProjects_some: FeedbackProjectWhereInput
  feedbackProjects_none: FeedbackProjectWhereInput
  feedbackRounds_every: FeedbackRoundWhereInput
  feedbackRounds_some: FeedbackRoundWhereInput
  feedbackRounds_none: FeedbackRoundWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`